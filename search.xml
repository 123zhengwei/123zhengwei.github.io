<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java基础（三）</title>
      <link href="/2019/06/08/java003/"/>
      <url>/2019/06/08/java003/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><a id="more"></a><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>1.声明数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型[ ] 数组名;   //或者: 数据类型 数组名[ ];</span><br><span class="line">eg:</span><br><span class="line">int ages[];      //存放年龄的数组，类型为整型</span><br><span class="line">char symbol[];   //存放符号的数组，类型为字符型</span><br><span class="line">String [] name;  //存放名称的数组，类型为字符串型</span><br></pre></td></tr></table></figure></p><p>2.创建数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名 = new  数据类型 [ 数组长度 ];</span><br><span class="line">eg:</span><br><span class="line">int [] ages = &#123;12,18,9,33,45,60&#125;; //声明并初始化了一个整型数组，它有6个元素</span><br><span class="line">char [] symbol = new char[10] //声明并分配了一个长度为10的char型数组</span><br></pre></td></tr></table></figure></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int [] ages = &#123;12, 18, 9, 33, 45, 60&#125;;</span><br><span class="line">for(int i = 0; i &lt; ages.length; i++)&#123; //ages.length是获取数组的长度</span><br><span class="line">    System.out.println(&quot;数组中第&quot;+(i+1)+&quot;个元素是 &quot;+ages[i]); //数组下标是从零开始，一定要注意</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>1.数组下标从 0 开始。所以数组的下标范围是 0 至 数组长度 -1。<br>2.数组不能越界访问，否则会报错。<br>3.for 语句在数组内可以使用特殊简化版本，在遍历数组、集合时，foreach 更简单便捷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素变量:遍历对象)&#123;</span><br><span class="line">    执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组的最值"><a href="#数组的最值" class="headerlink" title="数组的最值"></a>数组的最值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxNum = arr[0];</span><br><span class="line">int maxIndex = 0;</span><br><span class="line">for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i]&gt;maxNum)&#123;</span><br><span class="line">        maxNum = arr[i];</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(a,1,a1,0,4);</span><br><span class="line">内容依次是：源数组，源起始下标，目标数组，目起，要复制元素的个数；</span><br></pre></td></tr></table></figure><h3 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = Arrays.copyof(a,a.length+1);</span><br></pre></td></tr></table></figure><h3 id="将字符串→数组"><a href="#将字符串→数组" class="headerlink" title="将字符串→数组"></a>将字符串→数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[] input = str.tocharArray();</span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = (Math.random())*((右区间-左区间+1)+左区间); //[左区间,右区间)</span><br></pre></td></tr></table></figure><h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><h4 id="数组排序各种算法的时间复杂度"><a href="#数组排序各种算法的时间复杂度" class="headerlink" title="数组排序各种算法的时间复杂度"></a>数组排序各种算法的时间复杂度</h4><p><img src="https://s2.ax1x.com/2019/06/09/VDONM4.png" alt="VDONM4.png"><br> 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。<br> 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。<br><a href="https://www.bilibili.com/video/av10992425/?spm_id_from=333.788.videocard.8" title="链接" target="_blank" rel="noopener">9种排序算法在四种数据分布下的速度比较</a></p><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>1.直接插入排序  </p><ul><li>基本思想<br>直接插入排序是将未排序的数据插入至已排好序序列的合适位置。  </li><li>例子<br>{4,5,1,2,8,6,7,3,10,9}<br>取无序区间的第一个，从右向左扫描有序区间比较，方括号内可视为有序区间。<br>第一次：[4],5,1,2,8,6,7,3,10,9<br>第二次：[4,5],1,2,8,6,7,3,10,9<br>第三次：[1,4,5],2,8,6,7,3,10,9<br>第四次：[1,2,4,5],8,6,7,3,10,9<br>第五次：[1,2,4,5,8],6,7,3,10,9<br>第六次：[1,2,4,5,6,8],7,3,10,9<br>第七次：[1,2,4,5,6,7,8],3,10,9<br>第八次：[1,2,3,4,5,6,7,8],10,9<br>第九次：[1,2,3,4,5,6,7,8,10],9<br>第十次：[1,2,3,4,5,6,7,8,9,10]  </li><li>算法分析<br>直接插入排序算法的空间复杂度为O(1)<br>最好的情况，要比较的无序序列原本就是顺序有序的，那么要比较的次数是n-1，移动了0次，时间复杂度O(n)<br>最坏的情况，要比较的无序序列原本就是逆序有序的，那么要比较的次数是(n+2)(n-1)/2，移动的次数(n+4)(n-1)/2，时间复杂度O(n²)<br>直接插入排序的平均复杂度为O(n²)    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] data)&#123;</span><br><span class="line">   </span><br><span class="line">   int temp;</span><br><span class="line">   for (int i = 1; i &lt; data.length; i++) &#123;</span><br><span class="line">       temp = data[i];//待插入数据</span><br><span class="line">       int j;</span><br><span class="line">       for(j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">           //判断是否大于temp，大于则后移一位</span><br><span class="line">           if(data[j] &gt; temp) &#123;</span><br><span class="line">                data[j+1] = data[j];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       data[j + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.希尔排序 (分组插入) </p><ul><li>基本思想<br>希尔排序严格来说是基于插入排序的思想，又被称为缩小增量排序。<br>具体流程如下：<br>1、将包含n个元素的数组，分成n/2个数组序列，第一个数据和第n/2+1个数据为一对…<br>2、对每对数据进行比较和交换，排好顺序；<br>3、然后分成n/4个数组序列，再次排序；<br>4、不断重复以上过程，随着序列减少并直至为1，排序完成。  </li><li>例子<br>假如有初始数据：25  11 45  26  12  78。<br>1、第一轮排序，将该数组分成 6/2=3 个数组序列，第1个数据和第4个数据为一对，第2个数据和第5个数据为一对，<br>第3个数据和第6个数据为一对，每对数据进行比较排序，排序后顺序为：[25, 11, 45, 26,12, 78]。<br>2、第二轮排序，将上轮排序后的数组分成6/4=1个数组序列，此时逐个对数据比较，<br>按照插入排序对该数组进行排序，排序后的顺序为：[11, 12, 25, 26, 45, 78]。  </li><li>算法分析<br>对于插入排序而言，如果原数组是基本有序的，那排序效率就可大大提高。另外，对于数量较小的序列使用直接插入排序，会因需要移动的数据量少，其效率也会提高。因此，希尔排序具有较高的执行效率。<br>希尔排序并不稳定，O(1)的额外空间，时间复杂度为O(n²)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static voidshellSortSmallToBig(int[] data) &#123;</span><br><span class="line"></span><br><span class="line">   int j = 0;</span><br><span class="line">   int temp = 0;</span><br><span class="line">   for (int increment = data.length / 2; increment &gt; 0; increment /= 2)&#123;</span><br><span class="line">       for (int i = increment; i &lt; data.length; i++) &#123;</span><br><span class="line">           temp = data[i];</span><br><span class="line">           for (j = i - increment; j &gt;= 0; j -= increment) &#123;</span><br><span class="line">                if (temp &lt; data[j]) &#123;</span><br><span class="line">                    data[j + increment] =data[j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           data[j + increment] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>1.选择排序(冒泡改进)  </p><ul><li>基本思想<br>选择排序是一种简单直观的排序方法，每次寻找序列中的最小值，然后放在最末尾的位置。  </li><li>算法分析<br>时间复杂度:假设有n个数据，数据交换的次数最多为n-1次，但程序的总体的比较次数较多。所以综合考虑有直接选择排序的时间复杂度为O(n^2)。所以当记录占用字节数较多时，通常比直接插入排序的执行速度快些。<br>空间复杂度:直接选择排序的空间复杂度很好，它只需要一个附加单元用于数据交换，所以其空间复杂度为O(1)。<br>稳定性:由于在直接选择排序中存在着不相邻元素之间的互换，因此，直接选择排序是一种不稳定的排序方法。  </li><li>例子<br>以(49,38.65.97.76.13.27.49)为例<br>第一趟排序后:13[49,38,65,97,76,27,49]<br>第二趟排序后:13,27[49,38,65,97,76,49]<br>第三趟排序后:13,27,38[49,65,97,76.49]<br>第四趟排序后:13,27,38,49[65,97,76,49]<br>第五趟排序后:13,27,38,49,49[65,97,76]<br>第六趟排序后:13,27,38,49,49,65[97,76]<br>第七趟排序后:13,27,38,49,49,65,76[97]<br>最后的排序结果:<br>13,27,38,49,49,65,76,97<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] data) &#123;</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">       int temp = data[i];</span><br><span class="line">       int flag = i; //将当前下标定义为最小值下标</span><br><span class="line">       for (int j = i + 1; j &lt; data.length; j++) &#123;</span><br><span class="line">           if (data[j] &lt; temp) &#123; //a[j] &lt; temp 从小到大排序；a[j] &gt;temp 从大到小排序</span><br><span class="line">                temp = data[j];</span><br><span class="line">                flag = j; //如果有小于当前最小值的关键字将此关键字的下标赋值给flag</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (flag != i) &#123;</span><br><span class="line">           data[flag] = data[i];</span><br><span class="line">           data[i] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.堆排序  </p><ul><li>基本思想<br>堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。<br><img src="https://s2.ax1x.com/2019/06/09/VDXGTI.png" alt="VDXGTI.png"><br>堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。<br>堆排序的实现需要解决的两个关键问题：<br>（1）将一个无序序列构成一个堆。<br>（2）输出堆顶元素后，调整剩余元素成为一个新堆。  </li><li>算法分析<br>堆排序的运行时间主要耗费在初始构建堆和在重建堆时反复筛选上。在构建对的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较和若有必要的互换，对每个非终端节点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。<br>在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个节点到根节点的距离为这里写图片描述），并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。<br>所以总体来说，堆排序的时间复杂度为O(nlogn)，由于堆排序对原始记录的状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(nlogn)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的时间复杂度了。<br>空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行的，因此堆排序也是一种不稳定的排序方法。<br>另外，由于出事构建堆所需要的比较次数比较多，因此，他并不适合待排序序列个数较少的情况。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> ① 初始化操作：将R[1..n]构造为初始堆；</span><br><span class="line"> ②每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆(亦称重建堆)。</span><br><span class="line"> 注意：</span><br><span class="line"> ①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。</span><br><span class="line"> ②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。</span><br><span class="line"> */</span><br><span class="line">public static void adjustHeap(int[] data,int i, int len) &#123;</span><br><span class="line"></span><br><span class="line">inttemp, j;</span><br><span class="line">   temp = data[i];</span><br><span class="line">  for (j = 2 * i; j &lt; len; j *= 2) &#123; //沿关键字较大的孩子结点向下筛选</span><br><span class="line">       if (j &lt; len &amp;&amp; data[j] &lt; data[j + 1]) &#123;</span><br><span class="line">           ++j; //j为关键字中较大记录的下标</span><br><span class="line">       &#125;</span><br><span class="line">       if (temp &gt;= data[j]) &#123;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">       data[i] = data[j];</span><br><span class="line">       i = j;</span><br><span class="line">    &#125;</span><br><span class="line">   data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 堆排序</span><br><span class="line">public static void heapSort(int[] data) &#123;</span><br><span class="line">   int i;</span><br><span class="line">   for (i = data.length / 2 - 1; i &gt;= 0; i--) &#123; //构建一个大顶堆</span><br><span class="line">       adjustHeap(data, i, data.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">   for (i = data.length - 1; i &gt;= 0; i--) &#123; //将堆顶记录和当前未经排序子序列的最后一个记录交换</span><br><span class="line">       int temp = data[0];</span><br><span class="line">       data[0] = data[i];</span><br><span class="line">       data[i] = temp;</span><br><span class="line">       adjustHeap(data, 0, i - 1); //将a中前i-1个记录重新调整为大顶堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><p>1.冒泡排序   </p><ul><li>基本思想<br>相邻元素两两比较，大的往后放  </li><li>算法分析<br>C:记录比较次数<br>Cmin = n-1<br>Cmax = n(n-1)/2 = O(n^2)<br>M:记录移动次数<br>Mmin = 0<br>Mmax = 3n(n-1)/2= O(n^2)<br>综上所述：冒泡排序总的平均时间复杂度为：O(n^2) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] data)&#123;</span><br><span class="line"></span><br><span class="line">   int j , k;</span><br><span class="line">   int flag = data.length ;//flag来记录最后交换的位置，也就是排序的尾边界</span><br><span class="line">   while (flag &gt; 0)&#123;//排序未结束标志</span><br><span class="line">       k = flag; //k 来记录遍历的尾边界</span><br><span class="line">       flag = 0;</span><br><span class="line">       for(j=1; j&lt;k; j++)&#123;</span><br><span class="line">           if(data[j-1] &gt; data[j])&#123;//前面的数字大于后面的数字就交换</span><br><span class="line">                //交换a[j-1]和a[j]</span><br><span class="line">                int temp;</span><br><span class="line">                temp = data[j-1];</span><br><span class="line">                data[j-1] = data[j];</span><br><span class="line">                data[j]=temp;</span><br><span class="line">                //表示交换过数据</span><br><span class="line">                flag = j;//记录最新的尾边界</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.快速排序(挖坑填数+分治法)  </p><ul><li>基本思想<br>快速排序使用分治法策略来把一个序列分为两个子序列。<br>从数列中挑出一个元素，称为“基准”<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）<br>在这个分割之后，该基准是它的最后位置。这个称为分割（partition）操作。<br>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。  </li><li>算法分析<br>快速排序最“快”的地方在于左右两边能够快速同时递归排序下去，所以最优的情况是基准值刚好取在无序区的中间，这样能够最大效率地让两边排序，同时最大地减少递归划分的次数。此时的时间复杂度仅为O(NlogN)。<br>快速排序也有存在不足的情况，当每次划分基准值时，得到的基准值总是当前无序区域里最大或最小的那个元素，这种情况下基准值的一边为空，另一边则依然存在着很多元素(仅仅比排序前少了一个)，此时时间复杂度为：O(n^2) 。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">//快排</span><br><span class="line">public class KPSort &#123;</span><br><span class="line">// static int a[] = new int[10];</span><br><span class="line">static int a[] = &#123;12,64,31,33,98,46,75,67,10,23&#125;;</span><br><span class="line"></span><br><span class="line">private static  void Sort(int[]a,int low,int high)&#123;</span><br><span class="line">//结束条件</span><br><span class="line">if(low&gt;=high)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//i,j</span><br><span class="line">int i = low;</span><br><span class="line">int j = high;</span><br><span class="line">//key</span><br><span class="line">int key = a[i];</span><br><span class="line">//大于基准</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">while(a[j]&gt;key&amp;&amp;i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[i];</span><br><span class="line">a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">while(a[i]&lt;key&amp;&amp;i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//对基准左侧的集合重复操作</span><br><span class="line">Sort(a,low,i-1);</span><br><span class="line">Sort(a,i+1,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main (String[] args)&#123;</span><br><span class="line">System.out.println(&quot;未经排序的数组:&quot;+Arrays.toString(a));</span><br><span class="line">Sort(a,0,a.length-1);</span><br><span class="line">System.out.println(&quot;快排后的数组:&quot;+Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><ul><li>基本思想<br>归并排序就是利用归并的思想实现的排序方法。归并是指将两个已经排序的序列合并成一个序列的操作，而且充分利用了完全二叉树的深度是log₂n+1的特性，因此效率比较高。其基本原理如下：对于给定的一组记录，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。<br>经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，知道进行比较的记录只剩下一个为止。</li><li><p>工作原理：<br>(1)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>(2)设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>(3)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>(4)重复步骤3直到某一指针达到序列尾<br>(5)将另一序列剩下的所有元素直接复制到合并序列尾</p></li><li><p>算法分析<br>一趟归并需要将数组 a[]中相邻的长度为h的有序序列进行两两归并.并将结果放到temp[]中，这需要将待排序列中的所有记录扫描一遍，因此耗费O(n)，而又完全二叉树的深度可知，整个归并排序需要进行（log₂n）次，因此总的时间复杂度为O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。<br>由于归并排序在归并过程中需要与原始序列同样数量的存储空间存放归并结果以及递归时深度为log₂n的栈空间，因此空间复杂度为O(n+logn).<br>另外，对代码进行仔细研究，发现merge函数中有if (a[i] &lt; a[j]) 的语句，说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。<br>也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//将有序数组a[]和b[]放到c[]中 </span><br><span class="line">public static void mergeSort(int a[], int n, int b[],int m,int c[]) &#123;   </span><br><span class="line">    int i,j,k;</span><br><span class="line">i=j=k=0;</span><br><span class="line">    while (i&lt;n &amp;&amp; j&lt;m ) &#123;   </span><br><span class="line">        if (a[i]&lt;b[j])</span><br><span class="line">c[k++] = a[i++];</span><br><span class="line">else</span><br><span class="line">    c[k++] = b[j++];</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;n)</span><br><span class="line">  c[k++] = a[i++];</span><br><span class="line">while(j&lt;m)</span><br><span class="line">  c[k++] = b[j++];</span><br></pre></td></tr></table></figure><h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><ul><li>基本思想<br>像选择排序、插入排序、快速排序等都是基于两个元素的比较进行排序的。而基数排序无需进行元素比较，基于队列处理就能够达到排序的目的。<br>基数排序不是基于排序关键字来比较排序项，而是基于排序关键字的结构。对于排序关键字中的每一个数字或字符的每一种可能取值，都会创建一个单独的队列。队列的数目就称为基数。<br>例如：要排序全部由小写字母组成的字符串，则基数就是26，就会用到26个单独的队列。如果对十进制数进行排序，则基数应该是10。</li><li>算法分析<br>在基数排序中，没有任何元素的比较和交换，元素只是在每一轮中从一个队列移动到另一个队列。对于给定的基数，遍历数据的轮次是一个常数，它与排序关键字的数目无关，于是，基数排序算法的时间复杂度为O(n)。</li><li>局限<br>为什么不是所有的排序都使用基数排序算法呢？<br>1.基数排序算法要根据给定问题特别设计；<br>2.如果排序关键字中的数字数目与列表中元素的数目接近，那么算法的时间复杂度接近O(n平方)；<br>3.基数影响空间复杂度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static voidradixSort(int[] data)&#123;</span><br><span class="line"></span><br><span class="line">    String temp;</span><br><span class="line">    int numObj;</span><br><span class="line">    int digit,num;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt;[] digitQueue =(LinkedList&lt;Integer&gt;[])(new LinkedList[10]);</span><br><span class="line">    for(int digitVal = 0; digitVal &lt;= 9;digitVal++)&#123;</span><br><span class="line">        digitQueue[digitVal] =(Queue&lt;Integer&gt;)(new LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //sort</span><br><span class="line">    for(int pos = 0; pos &lt;= 3; pos++)&#123;</span><br><span class="line">        for(int scan = 0; scan &lt;data.length; scan++)&#123;</span><br><span class="line">            temp = String.valueOf(data[scan]);</span><br><span class="line">            digit =Character.digit(temp.charAt((3 - pos)), 10);</span><br><span class="line">            digitQueue[digit].add(newInteger(data[scan]));</span><br><span class="line">        &#125;</span><br><span class="line">        num = 0;</span><br><span class="line">        for(int digitVal = 0; digitVal &lt;= 9;digitVal++)&#123;</span><br><span class="line">           while(!(digitQueue[digitVal]).isEmpty())&#123;</span><br><span class="line">                numObj =digitQueue[digitVal].remove();</span><br><span class="line">                data[num] = numObj;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础（二）</title>
      <link href="/2019/06/08/java002/"/>
      <url>/2019/06/08/java002/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><a id="more"></a><h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line">    条件成立时执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="2.if…else语句"></a>2.if…else语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int days = 31;</span><br><span class="line">if(days &gt; 30)</span><br><span class="line">    System.out.println(&quot;本月是大月&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;本月是小月&quot;);</span><br></pre></td></tr></table></figure><p>注意：如果 if(或 else if，或 else)条件成立时的执行语句只有一条，是可以省略大括号的！但如果执行语句有多条，那么大括号就是不可或缺的。</p><h3 id="3-if…else-if…else语句"><a href="#3-if…else-if…else语句" class="headerlink" title="3.if…else if…else语句"></a>3.if…else if…else语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ScoreJudge &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int score = 78;</span><br><span class="line">        if(score &gt;= 60)&#123;</span><br><span class="line">            if(score &gt;= 80)&#123;</span><br><span class="line">                if(score &gt;= 90)&#123;</span><br><span class="line">                    System.out.println(&quot;成绩优秀&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    System.out.println(&quot;成绩良好&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                System.out.println(&quot;成绩及格&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            System.out.println(&quot;需要补考&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：所有的条件语句都是利用条件表达式的真或假来决定执行路径，Java 里不允许将一个数字作为布尔值使用，虽然这在C和C++是允许的，如果要在布尔测试里使用一个非布尔值，需要先用一个条件表达式将其转换成布尔值，其他控制语句同理。</p><h3 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4.switch 语句"></a>4.switch 语句</h3><p>当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Draw &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int num = 2;</span><br><span class="line">        switch(num)&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(&quot;恭喜你，获得了一等奖&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            System.out.println(&quot;恭喜你，获得了二等奖&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            System.out.println(&quot;恭喜你，获得了三等奖&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            System.out.println(&quot;很遗憾，下次再来&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-while和do-while语句"><a href="#5-while和do-while语句" class="headerlink" title="5.while和do-while语句"></a>5.while和do-while语句</h3><p>do-while 的执行过程是先执行，再判断（所以循环内的代码至少会执行一次）<br>先执行一遍循环操作，然后判断循环条件是否成立<br>如果条件成立，继续执行1.、2.，直到循环条件不成立为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SumOfEven &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int i1 = 1, i2 = 1;</span><br><span class="line">        int sum1 = 0, sum2 = 0;</span><br><span class="line"></span><br><span class="line">        while (i1 &lt;= 1000)&#123;     //循环1000次</span><br><span class="line">            if(0 == i1 % 2)&#123;   //判断是否为偶数</span><br><span class="line">                sum1 += i1;    //将偶数加入到总数里</span><br><span class="line">            &#125;</span><br><span class="line">            i1++;              //i自增1</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;用while，1到1000中，所有偶数的和为：&quot;+sum1);</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            if (0 == i2 % 2)&#123;   //在条件语句中，将数值写在前面是为了防止将==写成了=</span><br><span class="line">                sum2 += i2;</span><br><span class="line">            &#125;</span><br><span class="line">            i2++;</span><br><span class="line">        &#125; while(i2 &lt;= 1000);</span><br><span class="line">        System.out.println(&quot;用do-while，1到1000中，所有偶数的和为：&quot;+sum2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用while，1到1000中，所有偶数的和为：250500</span><br><span class="line">用do-while，1到1000中，所有偶数的和为：250500</span><br></pre></td></tr></table></figure></p><h3 id="6-for-语句"><a href="#6-for-语句" class="headerlink" title="6.for 语句"></a>6.for 语句</h3><p>for 相比 while 和 do-while 语句结构更加简洁易读，它的执行顺序：<br>1.执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次<br>2.进行循环条件的判断，如果条件为 true，则执行循环体内代码；如果为 false ，则直接退出循环<br>3.执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断<br>4.依次重新执行2.、3.、4.，直到退出循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SumOfOdd &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 1; i &lt;= 1000; i++)&#123;</span><br><span class="line">            if(0 == i % 2)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;用for，1到1000中，所有偶数和为：&quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-跳转语句"><a href="#7-跳转语句" class="headerlink" title="7.跳转语句"></a>7.跳转语句</h3><p>break关键字经常用在条件和循环语句中，用来跳出循环语句。<br>continue关键字的作用是跳过循环体中剩余的语句执行下一次循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Jump&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //break 练习</span><br><span class="line">        for(int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;循环第&quot;+i+&quot;次&quot;);</span><br><span class="line">            if(0 == i % 3)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //continue练习 打印10以内的所有奇数</span><br><span class="line">        for(int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">            if(0 == i % 2) //判断i是否为偶数</span><br><span class="line">                continue;  //通过continue结束本次循环</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">循环第1次</span><br><span class="line">循环第2次</span><br><span class="line">循环第3次</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">你需要在实现以下需求：</span><br><span class="line">从控制台获取一个整型参数</span><br><span class="line">当输入数字 1 时输出今天是星期一</span><br><span class="line">当输入数字 2 时输出今天是星期二</span><br><span class="line">......</span><br><span class="line">当输入数字 7 时输出今天是星期天</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class PrintWeek &#123;</span><br><span class="line"></span><br><span class="line">private static Scanner in;</span><br><span class="line"></span><br><span class="line">public static void main(String[] agrs)&#123;</span><br><span class="line">in = new Scanner(System.in);</span><br><span class="line">int a = in.nextInt();</span><br><span class="line">    if(a == 1)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期一&quot;);</span><br><span class="line">        &#125;else if(a == 2)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期二&quot;);</span><br><span class="line">            &#125;else if(a == 3)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期三&quot;);</span><br><span class="line">            &#125;else if(a == 4)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期四&quot;);</span><br><span class="line">             &#125;else if(a == 5)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期五&quot;);</span><br><span class="line">              &#125;else if(a == 6)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期六&quot;);</span><br><span class="line">                  &#125;else if(a == 7)&#123;</span><br><span class="line">    System.out.println(&quot;今天是星期天&quot;); </span><br><span class="line">                  &#125;else&#123;</span><br><span class="line">                  System.out.println(&quot;你是上帝吗？&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础（一）</title>
      <link href="/2019/06/08/java001/"/>
      <url>/2019/06/08/java001/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-变量-2-常量-3-数据类型-4-String-5-运算符-6-关键字和语句-7-方法"><a href="#1-变量-2-常量-3-数据类型-4-String-5-运算符-6-关键字和语句-7-方法" class="headerlink" title="1.变量 2.常量 3.数据类型 4.String 5.运算符 6.关键字和语句 7.方法"></a>1.变量 2.常量 3.数据类型 4.String 5.运算符 6.关键字和语句 7.方法</h2><a id="more"></a><h3 id="1-变量，常量用前定义"><a href="#1-变量，常量用前定义" class="headerlink" title="1.变量，常量用前定义"></a>1.变量，常量用前定义</h3><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><p><img src="https://s2.ax1x.com/2019/06/08/VBHCIU.png" alt="VBHCIU.png"></p><h3 id="3-String"><a href="#3-String" class="headerlink" title="3.String"></a>3.String</h3><h4 id="计算字符串长度：length-方法"><a href="#计算字符串长度：length-方法" class="headerlink" title="计算字符串长度：length()方法"></a>计算字符串长度：length()方法</h4><h4 id="字符串比较：equals-equalsIgnoreCase-”-”三者的区别"><a href="#字符串比较：equals-equalsIgnoreCase-”-”三者的区别" class="headerlink" title="字符串比较：equals(),equalsIgnoreCase(),”==”三者的区别"></a>字符串比较：equals(),equalsIgnoreCase(),”==”三者的区别</h4><p>☆equals() 方法,该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。equals() 方法比较是从第一字符开始，一个字符一个字符依次比较<br>☆如果想忽略掉大小写关系，比如：java 和 Java 是一样的，那怎么办呢？可以调用<br>equalsIgnoreCase()方法，其用法与 equals 一致，不过它会忽视大小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String s = new String(&quot;Java&quot;);</span><br><span class="line">        String m = &quot;java&quot;;</span><br><span class="line">        System.out.println(&quot;用equals()比较，java和Java结果为&quot;+s.equals(m));</span><br><span class="line">        System.out.println(&quot;用equalsIgnoreCase()比较，java和Java结果为&quot;+s.equalsIgnoreCase(m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用equals()比较，java和Java结果为false</span><br><span class="line">用equalsIgnoreCase()比较，java和Java结果为true</span><br></pre></td></tr></table></figure></p><p>☆使用”==”比较的是两个对象在内存中存储的地址是否一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;abc&quot;;</span><br><span class="line">String s2 = new String(&quot;abc&quot;);</span><br><span class="line">boolean b = (s1 == s2);</span><br></pre></td></tr></table></figure></p><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>使用+进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s0 = new String(&quot;Hello &quot;);</span><br><span class="line">String s1 = &quot;World&quot; + &quot;!&quot;;   //+号连接</span><br><span class="line">String s2 = s0.concat(s1); //concat()方法连接</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure></p><p>charAt()方法<br>charAt()方法的作用是按照索引值(规定字符串中第一个字符的索引值是 0，第二个字符的索引值是 1，依次类推)，获得字符串中的指定字符。例如：则变量 c 的值是’b’。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abc&quot;;</span><br><span class="line">char c = s.charAt(1);</span><br></pre></td></tr></table></figure></p><h4 id="字符串常用提取方法"><a href="#字符串常用提取方法" class="headerlink" title="字符串常用提取方法"></a>字符串常用提取方法</h4><p><img src="https://s2.ax1x.com/2019/06/08/VBOEtK.png" alt="VBOEtK.png"><br>去除字符串里的空格<br>1.str.trim();  是去掉首尾空格<br>2.str.replace(“ “, “”); 去掉所有空格，包括首尾、中间或者 str.replaceAll(“ +”, “”); 3.str = .replaceAll(“\s*”, “”); 可以替换大部分空白字符,不限于空格<br>\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个<br>小练习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">从控制台输入字符串 a 和字符串 b  </span><br><span class="line">比较字符串 a 和字符 b 是否完全一致，长度，内容等完全一致。  </span><br><span class="line">如果完全一致，输出相同，如果不一致，输出不同。  </span><br><span class="line">禁止使用equals方法</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ContrastString &#123;</span><br><span class="line">    private static Scanner in;</span><br><span class="line"></span><br><span class="line">    //重写equals方法</span><br><span class="line">public static boolean compare(String a, String b) &#123;</span><br><span class="line">        //将字符串转换为数组</span><br><span class="line">        char[] aChars = a.toCharArray();</span><br><span class="line">        char[] bChars = b.toCharArray();</span><br><span class="line">        List&lt;Character&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char aChar : aChars) &#123;</span><br><span class="line">            aList.add(aChar);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Character&gt; bList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char bChar : bChars) &#123;</span><br><span class="line">            bList.add(bChar);</span><br><span class="line">        &#125;</span><br><span class="line">        //是否为空</span><br><span class="line">        if(a == null || b == null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">        &#125;//比较串长</span><br><span class="line">        if(a.length()==b.length())&#123;</span><br><span class="line">        return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历比较内容</span><br><span class="line">        for (int i = 0; i&lt;a.length(); i++) &#123;</span><br><span class="line">            if(aChars[i] != bChars[i])&#123;</span><br><span class="line">            return false;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">public static void main(String[] agrs)&#123;</span><br><span class="line">in = new Scanner(System.in);</span><br><span class="line">    String a = in.nextLine();</span><br><span class="line">    String b = in.nextLine();</span><br><span class="line">System.out.println(compare(a, b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-算术运算符"><a href="#4-算术运算符" class="headerlink" title="4.算术运算符"></a>4.算术运算符</h3><p><img src="https://s2.ax1x.com/2019/06/08/VBjKot.png" alt="VBjKot.png"></p><h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5.位运算符"></a>5.位运算符</h3><p><img src="https://s2.ax1x.com/2019/06/08/VBjvff.png" alt="VBjvff.png"></p><h3 id="6-逻辑运算符"><a href="#6-逻辑运算符" class="headerlink" title="6.逻辑运算符"></a>6.逻辑运算符</h3><p><img src="https://s2.ax1x.com/2019/06/08/VBvncF.png" alt="VBvncF.png"></p><h3 id="7-关系运算符"><a href="#7-关系运算符" class="headerlink" title="7.关系运算符"></a>7.关系运算符</h3><p><img src="https://s2.ax1x.com/2019/06/08/VBvY9K.png" alt="VBvY9K.png"></p><h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h3><p>方法的定义语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br><span class="line">public void functionName(Object arg)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据方法是否带参、是否带返回值,可将方法分为四类：<br>无参无返回值方法<br>无参带返回值方法<br>带参无返回值方法<br>带参带返回值方法  </p>]]></content>
      
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 60个必会命令(1)安装与登陆命令。</title>
      <link href="/2018/12/28/linux002/"/>
      <url>/2018/12/28/linux002/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重在积累-争取每天拿下一个Linux命令。"><a href="#重在积累-争取每天拿下一个Linux命令。" class="headerlink" title="重在积累,争取每天拿下一个Linux命令。"></a>重在积累,争取每天拿下一个Linux命令。</h1><p><img src="https://s1.ax1x.com/2018/12/28/FWBrlQ.jpg" alt="FWBrlQ.jpg"><br><a id="more"></a></p><h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p>1.作用</p><p>login的作用是登录系统，它的使用权限是所有用户。</p><p>2.格式</p><p>login [name][－p ][－h 主机名称]</p><p>3.主要参数</p><p>－p:通知login保持现在的环境参数。</p><p>－h:用来向远程登录的之间传输用户名。</p><p>如果选择用命令行模式登录Linux的话，那么看到的第一个Linux命令就是login：。</p><p>一般界面是这样的：</p><p>Manddrake Linux release 9.1(Bamboo) for i586<br>renrel 2.4.21－0.13mdk on i686 / tty1<br>localhost login:root<br>password:</p><p>上面代码中，第一行是Linux发行版本号，第二行是内核版本号和登录的虚拟控制台，我们在第三行输入登录名，按“Enter”键在Password后输入账户密码，即可登录系统。出于安全考虑，输入账户密码时字符不会在屏幕上回显，光标也不移动。</p><p>登录后会看到下面这个界面（以超级用户为例）：</p><p>[root@localhost root]#<br>last login:Tue ,Nov 18 10:00:55 on vc/1</p><p>上面显示的是登录星期、月、日、时间和使用的虚拟控制台。</p><p>4.应用技巧</p><p>Linux是一个真正的多用户操作系统，可以同时接受多个用户登录，还允许一个用户进行多次登录。这是因为Linux和许多版本的Unix一样，提供了虚拟控制台的访问方式，允许用户在同一时间从控制台（系统的控制台是与系统直接相连的监视器和键盘）进行多次登录。每个虚拟控制台可以看作是一个独立的工作站，工作台之间可以切换。虚拟控制台的切换可以通过按下Alt键和一个功能键来实现，通常使用F1-F6 。</p><p>例如，用户登录后，按一下“Alt+F2”键，用户就可以看到上面出现的“login:”提示符，说明用户看到了第二个虚拟控制台。然后只需按“Alt+ F1”键，就可以回到第一个虚拟控制台。一个新安装的Linux系统允许用户使用“Alt+F1”到“Alt+F6”键来访问前六个虚拟控制台。虚拟控制台最有用的是，当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作，关闭这个程序。</p><h1 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h1><p>1.作用</p><p>shutdown命令的作用是关闭计算机，它的使用权限是超级用户。</p><p>2.格式</p><p>shutdown [－h][－i][－k][－m][－t]</p><p>3.重要参数</p><p>－t：在改变到其它运行级别之前，告诉init程序多久以后关机。</p><p>－k：并不真正关机，只是送警告信号给每位登录者。</p><p>－h：关机后关闭电源。</p><p>－c：cancel current process取消目前正在执行的关机程序。所以这个选项当然没有时间参数，但是可以输入一个用来解释的讯息，而这信息将会送到每位使用者。</p><p>－F：在重启计算机时强迫fsck。</p><p>－time：设定关机前的时间。</p><p>－m: 将系统改为单用户模式。</p><p>－i：关机时显示系统信息。</p><p>4.命令说明</p><p>shutdown命令可以安全地将系统关机。有些用户会使用直接断掉电源的方式来关闭Linux系统，这是十分危险的。因为Linux与Windows不同，其后台运行着许多进程，所以强制关机可能会导致进程的数据丢失，使系统处于不稳定的状态，甚至在有的系统中会损坏硬件设备（硬盘）。在系统关机前使用 shutdown命令，系统管理员会通知所有登录的用户系统将要关闭，并且login指令会被冻结，即新的用户不能再登录。</p><h1 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h1><p>1.作用</p><p>halt命令的作用是关闭系统，它的使用权限是超级用户。</p><p>2.格式</p><p>halt [－n] [－w] [－d] [－f] [－i] [－p]</p><p>3.主要参数说明</p><p>－n：防止sync系统调用，它用在用fsck修补根分区之后，以阻止内核用老版本的超级块覆盖修补过的超级块。</p><p>－w：并不是真正的重启或关机,只是写wtmp（/var/log/wtmp）纪录。</p><p>－f：没有调用shutdown，而强制关机或重启。</p><p>－i：关机（或重启）前，关掉所有的网络接口。</p><p>－f：强迫关机，不呼叫shutdown这个指令。</p><p>－p: 当关机的时候顺便做关闭电源的动作。</p><p>－d：关闭系统，但不留下纪录。　</p><p>4.命令说明</p><p>halt就是调用shutdown －h。halt执行时，杀死应用进程，执行sync(将存于buffer中的资料强制写入硬盘中)系统调用，文件系统写操作完成后就会停止内核。若系统的运行级别为0或6，则关闭系统；否则以shutdown指令（加上－h参数）来取代。　</p><h1 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h1><p>1.作用</p><p>reboot命令的作用是重新启动计算机，它的使用权限是系统管理者。</p><p>2.格式</p><p>reboot [－n] [－w] [－d] [－f] [－i]</p><p>3.主要参数</p><p>－n: 在重开机前不做将记忆体资料写回硬盘的动作。</p><p>－w: 并不会真的重开机，只是把记录写到/var/log/wtmp文件里。</p><p>－d: 不把记录写到/var/log/wtmp文件里（－n这个参数包含了－d）。</p><p>－i: 在重开机之前先把所有与网络相关的装置停止。</p><h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>1.作用</p><p>install命令的作用是安装或升级软件或备份数据，它的使用权限是所有用户。</p><p>2.格式</p><p>(1)install [选项]… 来源 目的地</p><p>(2)install [选项]… 来源… 目录</p><p>(3)install －d [选项]… 目录…</p><p>在前两种格式中，会将&lt;来源&gt;复制至&lt;目的地&gt;或将多个&lt;来源&gt;文件复制至已存在的&lt;目录&gt;，同时设定权限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。</p><p>3.主要参数</p><p>－－backup[=CONTROL]：为每个已存在的目的地文件进行备份。</p><p>－b：类似 －－backup，但不接受任何参数。</p><p>－c：(此选项不作处理)。</p><p>－d，－－directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。</p><p>－D：创建&lt;目的地&gt;前的所有主目录，然后将&lt;来源&gt;复制至 &lt;目的地&gt;；在第一种使用格式中有用。</p><p>－g，－－group=组：自行设定所属组，而不是进程目前的所属组。</p><p>－m，－－mode=模式：自行设定权限模式 (像chmod)，而不是rwxr－xr－x。</p><p>－o，－－owner=所有者：自行设定所有者 (只适用于超级用户)。</p><p>－p，－－preserve－timestamps：以&lt;来源&gt;文件的访问/修改时间作为相应的目的地文件的时间属性。</p><p>－s，－－strip：用strip命令删除symbol table，只适用于第一及第二种使用格式。</p><p>－S，－－suffix=后缀：自行指定备份文件的&lt;后缀&gt;。</p><p>－v，－－verbose：处理每个文件/目录时印出名称。</p><p>－－help：显示此帮助信息并离开。</p><p>－－version：显示版本信息并离开。</p><h1 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h1><p>1.作用</p><p>mount命令的作用是加载文件系统，它的用权限是超级用户或/etc/fstab中允许的使用者。</p><p>2.格式</p><p>mount －a [－fv] [－t vfstype] [－n] [－rw] [－F] device dir</p><p>3.主要参数</p><p>－h：显示辅助信息。</p><p>－v：显示信息，通常和－f用来除错。</p><p>－a：将/etc/fstab中定义的所有文件系统挂上。</p><p>－F：这个命令通常和－a一起使用，它会为每一个mount的动作产生一个行程负责执行。在系统需要挂上大量NFS文件系统时可以加快加载的速度。</p><p>－f：通常用于除错。它会使mount不执行实际挂上的动作，而是模拟整个挂上的过程，通常会和－v一起使用。</p><p>－t vfstype：显示被加载文件系统的类型。</p><p>－n：一般而言，mount挂上后会在/etc/mtab中写入一笔资料，在系统中没有可写入文件系统的情况下，可以用这个选项取消这个动作。</p><p>4.应用技巧</p><p>在Linux和Unix系统上，所有文件都是作为一个大型树（以/为根）的一部分访问的。要访问CD-ROM上的文件，需要将CD-ROM设备挂装在文件树中的某个挂装点。如果发行版安装了自动挂装包，那么这个步骤可自动进行。在Linux中，如果要使用硬盘、光驱等储存设备，就得先将它加载，当储存设备挂上了之后，就可以把它当成一个目录来访问。挂上一个设备使用mount命令。在使用mount这个指令时，至少要先知道下列三种信息：要加载对象的文件系统类型、要加载对象的设备名称及要将设备加载到哪个目录下。</p><p>（1）Linux可以识别的文件系统</p><p>◆ Windows 95/98常用的FAT 32文件系统：vfat ；</p><p>◆ Win NT/2000 的文件系统：ntfs ；</p><p>◆ OS/2用的文件系统：hpfs；</p><p>◆ Linux用的文件系统：ext2、ext3；</p><p>◆ CD-ROM光盘用的文件系统：iso9660。</p><p>虽然vfat是指FAT 32系统，但事实上它也兼容FAT 16的文件系统类型。</p><p>（2）确定设备的名称</p><p>在Linux中，设备名称通常都存在/dev里。这些设备名称的命名都是有规则的，可以用“推理”的方式把设备名称找出来。例如，/dev/hda1这个 IDE设备，hd是Hard Disk(硬盘)的，sd是SCSI Device，fd是Floppy Device(或是Floppy Disk?)。a代表第一个设备，通常IDE接口可以接上4个IDE设备(比如4块硬盘)。所以要识别IDE硬盘的方法分别就是hda、hdb、hdc、 hdd。hda1中的“1”代表hda的第一个硬盘分区 (partition)，hda2代表hda的第二主分区，第一个逻辑分区从hda5开始，依此类推。此外，可以直接检查/var/log/messages文件，在该文件中可以找到计算机开机后系统已辨认出来的设备代号。</p><p>（3）查找挂接点</p><p>在决定将设备挂接之前，先要查看一下计算机是不是有个/mnt的空目录，该目录就是专门用来当作挂载点(Mount Point)的目录。建议在/mnt里建几个/mnt/cdrom、/mnt/floppy、/mnt/mo等目录，当作目录的专用挂载点。举例而言，如要挂载下列5个设备，其执行指令可能如下 (假设都是Linux的ext2系统，如果是Windows XX请将ext2改成vfat)：</p><p>软盘 ===&gt;mount －t ext2 /dev/fd0 /mnt/floppy<br>cdrom ===&gt;mount －t iso9660 /dev/hdc /mnt/cdrom<br>SCSI cdrom ===&gt;mount －t iso9660 /dev/sdb /mnt/scdrom<br>SCSI cdr ===&gt;mount －t iso9660 /dev/sdc /mnt/scdr</p><p>不过目前大多数较新的Linux发行版本（包括红旗 Linux、中软Linux、Mandrake Linux等）都可以自动挂装文件系统，但Red Hat Linux除外。</p><h1 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h1><p>1.作用</p><p>umount命令的作用是卸载一个文件系统，它的使用权限是超级用户或/etc/fstab中允许的使用者。</p><p>2.格式</p><p>unmount －a [－fFnrsvw] [－t vfstype] [－n] [－rw] [－F] device dir</p><p>3.使用说明</p><p>umount命令是mount命令的逆操作，它的参数和使用方法和mount命令是一样的。Linux挂装CD-ROM后，会锁定CD—ROM，这样就不能用CD-ROM面板上的Eject按钮弹出它。但是，当不再需要光盘时，如果已将/cdrom作为符号链接，请使用umount/cdrom来卸装它。仅当无用户正在使用光盘时，该命令才会成功。该命令包括了将带有当前工作目录当作该光盘中的目录的终端窗口。</p><h1 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h1><p>1.作用</p><p>chsh命令的作用是更改使用者shell设定，它的使用权限是所有使用者。</p><p>2.格式</p><p>chsh [ －s ] [ －list] [ －－help ] [ －v ] [ username ]</p><p>3.主要参数</p><p>－l：显示系统所有Shell类型。</p><p>－v：显示Shell版本号。</p><p>4.应用技巧</p><p>前面介绍了Linux下有多种Shell，一般缺省的是Bash，如果想更换Shell类型可以使用chsh命令。先输入账户密码，然后输入新Shell类型，如果操作正确系统会显示“Shell change”。其界面一般如下：</p><p>Changing fihanging shell for cao<br>Password:<br>New shell [/bin/bash]: /bin/tcsh</p><p>上面代码中，[ ]内是目前使用的Shell。普通用户只能修改自己的Shell，超级用户可以修改全体用户的Shell。要想查询系统提供哪些Shell，可以使用chsh -l 命令，见图1所示。</p><p>图1 系统可以使用的Shell类型</p><p>从图1中可以看到，笔者系统中可以使用的Shell有bash（缺省）、csh、sh、tcsh四种。</p><h1 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h1><p>1.作用</p><p>exit命令的作用是退出系统，它的使用权限是所有用户。</p><p>2.格式</p><p>exit</p><p>3.参数</p><p>exit命令没有参数，运行后退出系统进入登录界面。</p><h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1><p>1.作用</p><p>last命令的作用是显示近期用户或终端的登录情况，它的使用权限是所有用户。通过last命令查看该程序的log，管理员可以获知谁曾经或企图连接系统。</p><p>2.格式</p><p>1ast[—n][－f file][－t tty] [—h 节点][－I —IP][—1][－y][1D]</p><p>3.主要参数</p><p>－n：指定输出记录的条数。</p><p>－f file：指定用文件file作为查询用的log文件。</p><p>－t tty：只显示指定的虚拟控制台上登录情况。</p><p>－h 节点：只显示指定的节点上的登录情况。</p><p>－i IP：只显示指定的IP上登录的情况。</p><p>－1：用IP来显示远端地址。</p><p>－y：显示记录的年、月、日。</p><p>－ID：知道查询的用户名。</p><p>－x:显示系统关闭、用户登录和退出的历史。</p><h1 id="动手练习"><a href="#动手练习" class="headerlink" title="动手练习"></a>动手练习</h1><p>上面介绍了Linux安装和登录命令，下面介绍几个实例，动手练习一下刚才讲过的命令。</p><p>1.一次运行多个命令</p><p>在一个命令行中可以执行多个命令，用分号将各个命令隔开即可，例如：</p><p>＃last －x；halt</p><p>上面代码表示在显示系统关闭、用户登录和退出的历史后关闭计算机。</p><p>2.利用mount挂装文件系统访问Windows系统</p><p>许多Linux发行版本现在都可以自动加载Vfat分区来访问Windows系统，而Red Hat各个版本都没有自动加载Vfat分区，因此还需要进行手工操作。</p><p>mount可以将Windows分区作为Linux的一个“文件”挂接到Linux的一个空文件夹下，从而将Windows的分区和/mnt这个目录联系起来。因此，只要访问这个文件夹就相当于访问该分区了。首先要在/mnt下建立winc文件夹，在命令提示符下输入下面命令：</p><p>＃mount -t vfat /dev/hda1 /mnt/winc</p><p>即表示将Windows的C分区挂到Liunx的/mnt/winc目录下。这时，在/mnt/winc目录下就可以看到Windows中C盘的内容了。使用类似的方法可以访问Windows系统的D、E盘。在Linux系统显示Windows的分区一般顺序这样的：hda1为C盘、hda5为D盘、 hda6为E盘……以此类推。上述方法可以查看Windows系统有一个很大的问题，就是Windows中的所有中文文件名或文件夹名全部显示为问号 “？”，而英文却可以正常显示。我们可以通过加入一些参数让它显示中文。还以上面的操作为例，此时输入命令：</p><p>＃mount -t vfat -o iocharset=cp936 /dev/hda1 /mnt/winc</p><p>现在它就可以正常显示中文了。</p><p>3.使用mount加挂闪盘上的文件系统</p><p>在Linux下使用闪盘非常简单。Linux对USB设备有很好的支持，当插入闪盘后，闪盘被识别为一个SCSI盘，通常输入以下命令：</p><p>＃ mount /dev/sda1 /usb</p><p>就能够加挂闪盘上的文件系统。</p><h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>Linux命令与Shell</p><p>所谓Shell，就是命令解释程序，它提供了程序设计接口，可以使用程序来编程。学习Shell对于Linux初学者理解Linux系统是非常重要的。 Linux系统的Shell作为操作系统的外壳，为用户提供了使用操作系统的接口。Shell是命令语言、命令解释程序及程序设计语言的统称，是用户和 Linux内核之间的接口程序。如果把Linux内核想象成一个球体的中心，Shell就是围绕内核的外层。当从Shell或其它程序向Linux传递命令时，内核会做出相应的反应。Shell在Linux系统的作用和MS DOS下的COMMAND.COM和Windows 95/98 的 explorer.exe相似。Shell虽然不是系统核心的一部分，只是系统核心的一个外延，但它能够调用系统内核的大部分功能。因此，可以说 Shell是Unux/Linux最重要的实用程序。</p><p>Linux中的Shell有多种类型，其中最常用的是Bourne Shell(sh)、C Shell(csh)和Korn Shell(ksh)。大多数Linux发行版本缺省的Shell是Bourne Again Shell，它是Bourne Shell的扩展，简称bash，与Bourne Shell完全向后兼容，并且在Bourne Shell的基础上增加了很多特性。bash放在/bin/bash中，可以提供如命令补全、命令编辑和命令历史表等功能。它还包含了很多C Shell和Korn Shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。Linux系统中200多个命令中有40个是bash的内部命令，主要包括 exit、less、lp、kill、 cd、pwd、fc、fg等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 60个必会命令综述。</title>
      <link href="/2018/12/28/linux001/"/>
      <url>/2018/12/28/linux001/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重在积累-争取每天拿下一个Linux命令。"><a href="#重在积累-争取每天拿下一个Linux命令。" class="headerlink" title="重在积累,争取每天拿下一个Linux命令。"></a>重在积累,争取每天拿下一个Linux命令。</h1><p>Linux提供了大量的命令，利用它可以有效地完成大量的工作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。<br>所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统。<br>不同Linux发行版的命令数量不一样，但Linux发行版本最少的命令也有200多个。这里将按照命令在系统中的作用分成下面六个部分一一介绍。<br><a id="more"></a><br>◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；</p><p>◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；</p><p>◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；</p><p>◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup；</p><p>◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who；</p><p>◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说明一哈^-^</title>
      <link href="/2018/11/17/shengming/"/>
      <url>/2018/11/17/shengming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注意-这不是QQ空间"><a href="#注意-这不是QQ空间" class="headerlink" title="注意!这不是QQ空间"></a>注意!这不是QQ空间</h1><a id="more"></a><h2 id="不是QQ空间"><a href="#不是QQ空间" class="headerlink" title="不是QQ空间"></a>不是QQ空间</h2><h3 id="不是QQ空间-1"><a href="#不是QQ空间-1" class="headerlink" title="不是QQ空间"></a>不是QQ空间</h3><h4 id="重要的话说三遍-哈哈"><a href="#重要的话说三遍-哈哈" class="headerlink" title="(重要的话说三遍,哈哈)"></a>(重要的话说三遍,哈哈)</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 哈哈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDBC操作mysql实例</title>
      <link href="/2018/11/15/java-jdbc/"/>
      <url>/2018/11/15/java-jdbc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习了mysql-厌倦了在黑框里敲各种sql语句-错了还不好修改是原罪"><a href="#学习了mysql-厌倦了在黑框里敲各种sql语句-错了还不好修改是原罪" class="headerlink" title="学习了mysql,厌倦了在黑框里敲各种sql语句(错了还不好修改是原罪)"></a>学习了mysql,厌倦了在黑框里敲各种sql语句(错了还不好修改是原罪)</h1><h2 id="于是就选用了JDBC用java来对mysql进行操作"><a href="#于是就选用了JDBC用java来对mysql进行操作" class="headerlink" title="于是就选用了JDBC用java来对mysql进行操作"></a>于是就选用了JDBC用java来对mysql进行操作</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package link;</span><br><span class="line">import java.sql.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 使用JDBC连接数据库MySQL的过程</span><br><span class="line">* DataBase：zw， table：student；</span><br><span class="line">* 使用myeclipse对mysql数据库进行增删改查的基本操作。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class JDBCTest &#123;</span><br><span class="line">    public static Connection getConnection() throws SQLException,</span><br><span class="line">    java.lang.ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    //第一步：加载MySQL的JDBC的驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //取得连接的url,能访问MySQL数据库的用户名,密码:admin;数据库名:zw</span><br><span class="line">    String url = &quot;jdbc:mysql://localhost:3306/zw&quot;;</span><br><span class="line">    String username = &quot;root&quot;;</span><br><span class="line">    String password = &quot;admin&quot;;</span><br><span class="line">    </span><br><span class="line">    //第二步：创建与MySQL数据库的连接类的实例</span><br><span class="line">    Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line">    return con;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">    //第三步：获取连接类实例con，用con创建Statement对象类实例 sql_statement</span><br><span class="line">    Connection con = getConnection();</span><br><span class="line">    Statement sql_statement = con.createStatement();</span><br><span class="line">    </span><br><span class="line">    //如果同名数据库存在，删除</span><br><span class="line">    sql_statement.executeUpdate(&quot;drop table if exists student&quot;);</span><br><span class="line">    //执行了一个sql语句生成了一个名为student的表</span><br><span class="line">    sql_statement.executeUpdate(&quot;create table student (Sno char(10) primary key,Sname char(20) unique,Ssex char(4),Sage smallint,Sdept char(20) ); &quot;);</span><br><span class="line">    </span><br><span class="line">    //向student表中插入数据</span><br><span class="line">    sql_statement.executeUpdate(&quot;insert student values(&apos;B16060901&apos;,&apos;郑伟&apos;,&apos;男&apos;,21,&apos;CS&apos;)&quot;);</span><br><span class="line">    sql_statement.executeUpdate(&quot;insert student values(&apos;B16060902&apos;,&apos;王伟&apos;,&apos;男&apos;,20,&apos;AS&apos;)&quot;);</span><br><span class="line">    sql_statement.executeUpdate(&quot;insert student values(&apos;B16060903&apos;,&apos;张伟&apos;,&apos;男&apos;,21,&apos;BS&apos;)&quot;);</span><br><span class="line">    sql_statement.executeUpdate(&quot;insert student values(&apos;B16060904&apos;,&apos;刘伟&apos;,&apos;女&apos;,20,&apos;CS&apos;)&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //第四步：执行查询，用ResultSet类的对象，返回查询的结果</span><br><span class="line">    String query = &quot;select * from student&quot;;</span><br><span class="line">    ResultSet result = sql_statement.executeQuery(query);</span><br><span class="line">    </span><br><span class="line">    //显示数据中student表中的内容：</span><br><span class="line">    System.out.println(&quot;student表中的数据如下:&quot;);</span><br><span class="line">    System.out.println(&quot;------------------------------------------------------&quot;);</span><br><span class="line">    System.out.println(&quot;\t序号\t\t姓名\t性别\t年龄\t所在系&quot;);</span><br><span class="line">    System.out.println(&quot;------------------------------------------------------&quot;);</span><br><span class="line">    </span><br><span class="line">    //对获得的查询结果进行处理，对Result类的对象进行操作</span><br><span class="line">    while (result.next())&#123;</span><br><span class="line">    String number = result.getString(&quot;Sno&quot;);</span><br><span class="line">    String name = result.getString(&quot;Sname&quot;);</span><br><span class="line">    String sex = result.getString(&quot;Ssex&quot;);</span><br><span class="line">    int age = result.getInt(&quot;Sage&quot;);</span><br><span class="line">    String dept= result.getString(&quot;Sdept&quot;);</span><br><span class="line">    </span><br><span class="line">    //取得数据库中的数据</span><br><span class="line">    System.out.println(&quot;\t&quot;+ number + &quot;\t&quot; + name + &quot;\t&quot; + sex + &quot;\t&quot; + age + &quot;\t&quot; + dept +&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //第五步关闭连接和声明 这点很重要,不要忘记</span><br><span class="line">    sql_statement.close();</span><br><span class="line">    con.close();</span><br><span class="line">    </span><br><span class="line">    &#125; catch(java.lang.ClassNotFoundException e) &#123;</span><br><span class="line">    System.err.print(&quot;ClassNotFoundException&quot;);</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">    &#125; catch (SQLException ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="如果对eclipse-myeclipse连接mysql不是很清楚可以参考CSDN"><a href="#如果对eclipse-myeclipse连接mysql不是很清楚可以参考CSDN" class="headerlink" title="如果对eclipse/myeclipse连接mysql不是很清楚可以参考CSDN"></a>如果对eclipse/myeclipse连接mysql不是很清楚可以参考<a href="https://blog.csdn.net/qq_35134075/article/details/78367442" target="_blank">CSDN</a></h1><h2 id="连接关键就是对这张表的配置"><a href="#连接关键就是对这张表的配置" class="headerlink" title="连接关键就是对这张表的配置"></a>连接关键就是对这张表的配置</h2><p> <img src="https://s1.ax1x.com/2018/11/15/iv3mDI.png" alt="iv3mDI.png"></p><h1 id="最后希望可以在你java学习道路上帮一点小忙"><a href="#最后希望可以在你java学习道路上帮一点小忙" class="headerlink" title="最后希望可以在你java学习道路上帮一点小忙"></a>最后希望可以在你java学习道路上帮一点小忙</h1>]]></content>
      
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello! My friend.</title>
      <link href="/2018/11/13/hello-world/"/>
      <url>/2018/11/13/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to ZW blog.<br><a id="more"></a></p><p><img src="https://s1.ax1x.com/2018/11/15/ivKvwT.jpg" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=474435512&auto=1&height=66"></iframe>]]></content>
      
      
      
    </entry>
    
  
  
</search>
